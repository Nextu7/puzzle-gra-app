// Zawartość pliku /assets/puzzle-game-logic.js

window.ShopifyPuzzleGame = {
  init: function(modalNode) {
    if (modalNode.puzzleGameInitialized) return;
    modalNode.puzzleGameInitialized = true;

    const elements = {
      difficultySelect: modalNode.querySelector(".puzzle-select"),
      timerDisplay: modalNode.querySelector(".timer-display"),
      puzzleComplete: modalNode.querySelector(".puzzle-complete"),
      puzzleCompleteTime: modalNode.querySelector(".puzzle-complete-time"),
      gameArea: modalNode.querySelector(".puzzle-game-area"),
      svg: modalNode.querySelector(".puzzle-svg"),
      previewBtn: modalNode.querySelector(".puzzle-btn-preview"),
      startBtn: modalNode.querySelector(".puzzle-btn-start"),
      shuffleBtn: modalNode.querySelector(".puzzle-btn-shuffle"),
      resetBtn: modalNode.querySelector(".puzzle-btn-reset")
    };

    let puzzleState = { image: null, pieces: [], groups: [], difficulty: 'medium', draggedGroup: null, clickedPiece: null, dragOffset: { x: 0, y: 0 }, isComplete: false, SNAP_DISTANCE: 30, showPreview: false, startTime: null, timerInterval: null };
    const DIFFICULTY_LEVELS = { easy: { cols: 4, rows: 5 }, medium: { cols: 6, rows: 7 }, hard: { cols: 8, rows: 10 }, expert: { cols: 10, rows: 12 } };
    
    const initPuzzle = (imageUrl) => { const img = new Image(); img.crossOrigin = 'anonymous'; img.onload = function() { puzzleState.image = { src: img.src, width: img.width, height: img.height, aspectRatio: img.width / img.height }; createPuzzlePieces(); }; img.src = imageUrl; }
    const generatePuzzleShape = (connections, width, height) => { const tabW = width * 0.25, tabH = height * 0.25, neckW = width * 0.1, neckH = height * 0.1; let p = "M 0,0"; if (connections.top === "out") { const m = width / 2; p += ` L ${m - neckW},0 C ${m - neckW},-${tabH * 0.3} ${m - tabW},-${tabH} ${m},-${tabH} C ${m + tabW},-${tabH} ${m + neckW},-${tabH * 0.3} ${m + neckW},0 L ${width},0` } else if (connections.top === "in") { const m = width / 2; p += ` L ${m - neckW},0 C ${m - neckW},${tabH * 0.3} ${m - tabW},${tabH} ${m},${tabH} C ${m + tabW},${tabH} ${m + neckW},${tabH * 0.3} ${m + neckW},0 L ${width},0` } else p += ` L ${width},0`; if (connections.right === "out") { const m = height / 2; p += ` L ${width},${m - neckH} C ${width + tabW * 0.3},${m - neckH} ${width + tabW},${m - tabH} ${width + tabW},${m} C ${width + tabW},${m + tabH} ${width + tabW * 0.3},${m + neckH} ${width},${m + neckH} L ${width},${height}` } else if (connections.right === "in") { const m = height / 2; p += ` L ${width},${m - neckH} C ${width - tabW * 0.3},${m - neckH} ${width - tabW},${m - tabH} ${width - tabW},${m} C ${width - tabW},${m + tabH} ${width - tabW * 0.3},${m + neckH} ${width},${m + neckH} L ${width},${height}` } else p += ` L ${width},${height}`; if (connections.bottom === "out") { const m = width / 2; p += ` L ${m + neckW},${height} C ${m + neckW},${height + tabH * 0.3} ${m + tabW},${height + tabH} ${m},${height + tabH} C ${m - tabW},${height + tabH} ${m - neckW},${height + tabH * 0.3} ${m - neckW},${height} L 0,${height}` } else if (connections.bottom === "in") { const m = width / 2; p += ` L ${m + neckW},${height} C ${m + neckW},${height - tabH * 0.3} ${m + tabW},${height - tabH} ${m},${height - tabH} C ${m - tabW},${height - tabH} ${m - neckW},${height - tabH * 0.3} ${m - neckW},${height} L 0,${height}` } else p += ` L 0,${height}`; if (connections.left === "out") { const m = height / 2; p += ` L 0,${m + neckH} C -${tabW * 0.3},${m + neckH} -${tabW},${m + tabH} -${tabW},${m} C -${tabW},${m - tabH} -${tabW * 0.3},${m - neckH} 0,${m - neckH} L 0,0` } else if (connections.left === "in") { const m = height / 2; p += ` L 0,${m + neckH} C ${tabW * 0.3},${m + neckH} ${tabW},${m + tabH} ${tabW},${m} C ${tabW},${m - tabH} ${tabW * 0.3},${m - neckH} 0,${m - neckH} L 0,0` } else p += ` L 0,0`; return p + " Z" }
    const generateConnections = (cols, rows) => { const c = {}, l = []; for (let r = 0; r < rows; r++) for (let j = 0; j < cols; j++) { const i = r * cols + j; l.push({ id: i, row: r, col: j }); c[i] = { top: null, right: null, bottom: null, left: null } }; for (let r = 0; r < rows; r++) for (let j = 0; j < cols; j++) { const i = r * cols + j; if (r > 0) { const t = (r - 1) * cols + j; if (c[t].bottom === null) c[t].bottom = Math.random() > .5 ? "out" : "in"; c[i].top = c[t].bottom === "out" ? "in" : "out" } if (j > 0) { const L = r * cols + (j - 1); if (c[L].right === null) c[L].right = Math.random() > .5 ? "out" : "in"; c[i].left = c[L].right === "out" ? "in" : "out" } if (j < cols - 1) c[i].right = Math.random() > .5 ? "out" : "in"; if (r < rows - 1) c[i].bottom = Math.random() > .5 ? "out" : "in" } return { connections: c, layout: l } }
    const createPuzzlePieces = () => { if (!puzzleState.image) return; const lvl = DIFFICULTY_LEVELS[puzzleState.difficulty]; let cols, rows; if (puzzleState.image.aspectRatio > 1) { cols = lvl.rows; rows = lvl.cols } else { cols = lvl.cols; rows = lvl.rows } const { connections, layout } = generateConnections(cols, rows); const max = 500; let bw, bh; if (puzzleState.image.aspectRatio > 1) { bw = max; bh = max / puzzleState.image.aspectRatio } else { bh = max; bw = max * puzzleState.image.aspectRatio } const pw = bw / cols, ph = bh / rows; const ga = elements.gameArea.getBoundingClientRect(); const cx = ga.width / 2, cy = ga.height / 2; const tx = cx - bw / 2, ty = cy - bh / 2; puzzleState.targetPosition = { x: tx, y: ty, width: bw, height: bh }; const margin = 40, spacing = 20, areas = []; if (tx > pw + margin) areas.push({ x: spacing, y: spacing, width: tx - margin - spacing, height: ga.height - spacing * 2 }); if (ga.width - (tx + bw) > pw + margin) areas.push({ x: tx + bw + margin, y: spacing, width: ga.width - (tx + bw + margin) - spacing, height: ga.height - spacing * 2 }); if (ty > ph + margin) areas.push({ x: spacing, y: spacing, width: ga.width - spacing * 2, height: ty - margin - spacing }); if (ga.height - (ty + bh) > ph + margin) areas.push({ x: spacing, y: ty + bh + margin, width: ga.width - spacing * 2, height: ga.height - (ty + bh + margin) - spacing }); if (!areas.length) areas.push({ x: spacing, y: spacing, width: 200, height: ga.height - spacing * 2 }, { x: ga.width - 200 - spacing, y: spacing, width: 200, height: ga.height - spacing * 2 }); let pos = { area: 0, x: areas[0].x, y: areas[0].y, maxH: 0 }, positions = []; for (let i = 0; i < layout.length; i++) { const a = areas[pos.area]; if (pos.x + pw + spacing > a.x + a.width) { pos.x = a.x; pos.y += pos.maxH + spacing; pos.maxH = 0; if (pos.y + ph + spacing > a.y + a.height) { pos.area = (pos.area + 1) % areas.length; pos.x = areas[pos.area].x; pos.y = areas[pos.area].y } } positions[i] = { x: pos.x + (Math.random() - .5) * 10, y: pos.y + (Math.random() - .5) * 10 }; pos.x += pw + spacing; pos.maxH = Math.max(pos.maxH, ph) } puzzleState.pieces = layout.map(({ id, row, col }) => { const shape = generatePuzzleShape(connections[id], pw, ph), p = positions[id]; return { id, row, col, shape, connections: connections[id], x: p.x, y: p.y, correctX: tx + col * pw, correctY: ty + row * ph, groupId: id, zIndex: id + 1, isFixed: false, neighbors: { top: row > 0 ? (row - 1) * cols + col : null, right: col < cols - 1 ? id + 1 : null, bottom: row < rows - 1 ? (row + 1) * cols + col : null, left: col > 0 ? id - 1 : null }, boardWidth: bw, boardHeight: bh, pieceWidth: pw, pieceHeight: ph } }); puzzleState.groups = puzzleState.pieces.map(p => ({ id: p.groupId, pieces: [p.id], x: p.x, y: p.y })); renderPuzzle(); startTimer() }
    const renderPuzzle = () => { const svg = elements.svg; svg.innerHTML = ""; if (puzzleState.targetPosition && !puzzleState.isComplete) { if (puzzleState.showPreview) { const img = document.createElementNS("http://www.w3.org/2000/svg", "image"); img.setAttribute("href", puzzleState.image.src); img.setAttribute("x", puzzleState.targetPosition.x); img.setAttribute("y", puzzleState.targetPosition.y); img.setAttribute("width", puzzleState.targetPosition.width); img.setAttribute("height", puzzleState.targetPosition.height); img.setAttribute("opacity", "0.2"); img.setAttribute("preserveAspectRatio", "xMidYMid slice"); svg.appendChild(img) } else { const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect"); rect.setAttribute("x", puzzleState.targetPosition.x); rect.setAttribute("y", puzzleState.targetPosition.y); rect.setAttribute("width", puzzleState.targetPosition.width); rect.setAttribute("height", puzzleState.targetPosition.height); rect.setAttribute("fill", "rgba(0,0,0,0.05)"); rect.setAttribute("stroke", "#dee2e6"); rect.setAttribute("stroke-width", "2"); rect.setAttribute("stroke-dasharray", "10,5"); rect.setAttribute("rx", "8"); svg.appendChild(rect); const text = document.createElementNS("http://www.w3.org/2000/svg", "text"); text.setAttribute("pointer-events", "none"); text.style.userSelect = "none"; text.setAttribute("x", puzzleState.targetPosition.x + puzzleState.targetPosition.width / 2); text.setAttribute("y", puzzleState.targetPosition.y + puzzleState.targetPosition.height / 2); text.setAttribute("text-anchor", "middle"); text.setAttribute("dominant-baseline", "middle"); text.setAttribute("fill", "#adb5bd"); text.setAttribute("font-size", "24"); text.setAttribute("font-weight", "500"); text.textContent = "Ułóż puzzle tutaj"; svg.appendChild(text) } } const sorted = puzzleState.pieces.slice().sort((a, b) => (a.zIndex || 0) - (b.zIndex || 0)); sorted.forEach(piece => { const g = document.createElementNS("http://www.w3.org/2000/svg", "g"); g.setAttribute("class", "puzzle-piece"); g.setAttribute("transform", `translate(${piece.x},${piece.y})`); g.style.zIndex = piece.zIndex; const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs"), cp = document.createElementNS("http://www.w3.org/2000/svg", "clipPath"); const clipId = `clip-${modalNode.id}-${piece.id}`; cp.setAttribute("id", clipId); const pathClip = document.createElementNS("http://www.w3.org/2000/svg", "path"); pathClip.setAttribute("d", piece.shape); cp.appendChild(pathClip); defs.appendChild(cp); g.appendChild(defs); const imageG = document.createElementNS("http://www.w3.org/2000/svg", "g"); imageG.setAttribute("clip-path", `url(#${clipId})`); const imgEl = document.createElementNS("http://www.w3.org/2000/svg", "image"); imgEl.setAttribute("href", puzzleState.image.src); imgEl.setAttribute("x", -piece.col * piece.pieceWidth); imgEl.setAttribute("y", -piece.row * piece.pieceHeight); imgEl.setAttribute("width", piece.boardWidth); imgEl.setAttribute("height", piece.boardHeight); imgEl.setAttribute("preserveAspectRatio", "xMidYMid slice"); imageG.appendChild(imgEl); g.appendChild(imageG); const outline = document.createElementNS("http://www.w3.org/2000/svg", "path"); outline.setAttribute("d", piece.shape); outline.setAttribute("fill", "none"); outline.setAttribute("class", "puzzle-piece-shape"); g.appendChild(outline); g.addEventListener("mousedown", e => handleMouseDown(e, piece)); g.addEventListener("touchstart", e => handleTouchStart(e, piece), { passive: false }); svg.appendChild(g) }); elements.puzzleComplete.style.display = puzzleState.isComplete ? "block" : "none" }
    const handleMouseDown = (e, piece) => { if (piece.isFixed) return; e.preventDefault(); const g = puzzleState.groups.find(g => g.pieces.includes(piece.id)); if (!g) return; puzzleState.draggedGroup = g; puzzleState.clickedPiece = piece; const m = Math.max(...puzzleState.pieces.map(p => p.zIndex || 0), 0); puzzleState.pieces.forEach(p => { if (g.pieces.includes(p.id)) p.zIndex = m + 1 }); const r = elements.gameArea.getBoundingClientRect(); puzzleState.dragOffset = { x: e.clientX - r.left - piece.x, y: e.clientY - r.top - piece.y }; elements.gameArea.classList.add("dragging") }
    const handleTouchStart = (e, piece) => { e.preventDefault(); const t = e.touches[0]; handleMouseDown(new MouseEvent("mousedown", { clientX: t.clientX, clientY: t.clientY, bubbles: true }), piece); }
    const handleMouseMove = (e) => { if (!puzzleState.draggedGroup || !puzzleState.clickedPiece) return; const r = elements.gameArea.getBoundingClientRect(); const nx = e.clientX - r.left - puzzleState.dragOffset.x, ny = e.clientY - r.top - puzzleState.dragOffset.y; const dx = nx - puzzleState.clickedPiece.x, dy = ny - puzzleState.clickedPiece.y; puzzleState.pieces.forEach(p => { if (puzzleState.draggedGroup.pieces.includes(p.id)) { p.x += dx; p.y += dy } }); puzzleState.clickedPiece.x = nx; puzzleState.clickedPiece.y = ny; renderPuzzle() }
    const tryGroupSnap = (g) => { const ps = puzzleState.pieces.filter(p => g.pieces.includes(p.id)), minR = Math.min(...ps.map(p => p.row)), minC = Math.min(...ps.map(p => p.col)), refs = ps.map(p => ({ x: p.x - (p.col - minC) * p.pieceWidth, y: p.y - (p.row - minR) * p.pieceHeight })), r0 = refs[0]; if (!refs.every(r => Math.abs(r.x - r0.x) < puzzleState.SNAP_DISTANCE && Math.abs(r.y - r0.y) < puzzleState.SNAP_DISTANCE)) return !1; const cx = puzzleState.targetPosition.x + minC * ps[0].pieceWidth, cy = puzzleState.targetPosition.y + minR * ps[0].pieceHeight; if (Math.abs(r0.x - cx) < puzzleState.SNAP_DISTANCE && Math.abs(r0.y - cy) < puzzleState.SNAP_DISTANCE) { ps.forEach(p => { p.x = cx + (p.col - minC) * p.pieceWidth; p.y = cy + (p.row - minR) * p.pieceHeight; p.isFixed = !0 }); puzzleState.groups = puzzleState.groups.filter(x => x.id !== g.id); if (puzzleState.pieces.every(p => p.isFixed)) { puzzleState.isComplete = !0; stopTimer(); const e = Math.floor((Date.now() - puzzleState.startTime) / 1e3), m = Math.floor(e / 60), s = e % 60, txt = `Czas: ${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`; elements.puzzleCompleteTime.textContent = txt; elements.puzzleComplete.style.display = 'block'; elements.puzzleComplete.classList.add('celebrate'); setTimeout(() => elements.puzzleComplete.classList.remove('celebrate'), 600) } renderPuzzle(); return !0 } return !1 }
    const handleMouseUp = (e) => { if (!puzzleState.draggedGroup) return; if (tryGroupSnap(puzzleState.draggedGroup)) { puzzleState.draggedGroup = null; puzzleState.clickedPiece = null; elements.gameArea.classList.remove('dragging'); return } checkConnections(); puzzleState.draggedGroup = null; puzzleState.clickedPiece = null; elements.gameArea.classList.remove('dragging') }
    const canConnect = (p1, p2) => { const rn = p1.neighbors.right === p2.id, ln = p1.neighbors.left === p2.id, bn = p1.neighbors.bottom === p2.id, tn = p1.neighbors.top === p2.id; if (!rn && !ln && !bn && !tn) return null; const dx = p2.x - p1.x, dy = p2.y - p1.y, S = puzzleState.SNAP_DISTANCE; if (rn && Math.abs(dx - p1.pieceWidth) < S && Math.abs(dy) < S) return { offsetX: (p2.x - p1.pieceWidth) - p1.x, offsetY: p2.y - p1.y }; if (ln && Math.abs(dx + p2.pieceWidth) < S && Math.abs(dy) < S) return { offsetX: (p2.x + p2.pieceWidth) - p1.x, offsetY: p2.y - p1.y }; if (bn && Math.abs(dy - p1.pieceHeight) < S && Math.abs(dx) < S) return { offsetX: p2.x - p1.x, offsetY: (p2.y - p1.pieceHeight) - p1.y }; if (tn && Math.abs(dy + p2.pieceHeight) < S && Math.abs(dx) < S) return { offsetX: p2.x - p1.x, offsetY: (p2.y + p2.pieceHeight) - p1.y }; return null }
    const checkConnections = () => { const grp = puzzleState.draggedGroup; if (!grp) return; const arr = puzzleState.pieces.filter(p => grp.pieces.includes(p.id)); for (const p of arr) { const n = [p.neighbors.top, p.neighbors.right, p.neighbors.bottom, p.neighbors.left].filter(x => x !== null); for (const i of n) { const nb = puzzleState.pieces.find(x => x.id === i); if (!nb || grp.pieces.includes(nb.id)) continue; const c = canConnect(p, nb); if (c) { mergeGroups(p.groupId, nb.groupId, c); return } } } }
    const mergeGroups = (movingId, staticId, offsets) => { const m = puzzleState.groups.find(g => g.id === movingId), s = puzzleState.groups.find(g => g.id === staticId); if (!m || !s || m.id === s.id) return; puzzleState.pieces.forEach(p => { if (m.pieces.includes(p.id)) { p.x += offsets.offsetX; p.y += offsets.offsetY; p.groupId = s.id } }); puzzleState.groups = puzzleState.groups.filter(g => g.id !== m.id).map(g => g.id === s.id ? { ...g, pieces: [...g.pieces, ...m.pieces] } : g); renderPuzzle(); if (puzzleState.groups.length === 1 && puzzleState.pieces.every(p => p.isFixed)){puzzleState.isComplete = true; stopTimer(); const e = Math.floor((Date.now() - puzzleState.startTime) / 1000), m2 = Math.floor(e / 60), s2 = e % 60; elements.puzzleCompleteTime.textContent = `Czas: ${m2.toString().padStart(2, "0")}:${s2.toString().padStart(2, "0")}`; elements.puzzleComplete.style.display = 'block'; elements.puzzleComplete.classList.add("celebrate"); setTimeout(() => elements.puzzleComplete.classList.remove("celebrate"), 600)}}
    const shufflePieces = () => { if (puzzleState.isComplete || !puzzleState.image) return; const ga = elements.gameArea.getBoundingClientRect(), cx = ga.width / 2, cy = ga.height / 2, tx = cx - puzzleState.targetPosition.width / 2, ty = cy - puzzleState.targetPosition.height / 2, margin = 40, spacing = 20, pw = puzzleState.pieces[0].pieceWidth, ph = puzzleState.pieces[0].pieceHeight, areas = []; if (tx > pw + margin) areas.push({ x: spacing, y: spacing, width: tx - margin - spacing, height: ga.height - spacing * 2 }); if (ga.width - (tx + puzzleState.targetPosition.width) > pw + margin) areas.push({ x: tx + puzzleState.targetPosition.width + margin, y: spacing, width: ga.width - (tx + puzzleState.targetPosition.width + margin) - spacing, height: ga.height - spacing * 2 }); if (ty > ph + margin) areas.push({ x: spacing, y: spacing, width: ga.width - spacing * 2, height: ty - margin - spacing }); if (ga.height - (ty + puzzleState.targetPosition.height) > ph + margin) areas.push({ x: spacing, y: ty + puzzleState.targetPosition.height + margin, width: ga.width - spacing * 2, height: ga.height - (ty + puzzleState.targetPosition.height + margin) - spacing }); if (!areas.length) areas.push({ x: spacing, y: spacing, width: 200, height: ga.height - spacing * 2 }, { x: ga.width - 200 - spacing, y: spacing, width: 200, height: ga.height - spacing * 2 }); const order = Array.from({ length: puzzleState.pieces.length }, (_, i) => i).sort(() => Math.random() - .5), positions = [], st = { area: 0, x: areas[0].x, y: areas[0].y, maxH: 0 }; for (let i = 0; i < order.length; i++) { const a = areas[st.area]; if (st.x + pw + spacing > a.x + a.width) { st.x = a.x; st.y += st.maxH + spacing; st.maxH = 0; if (st.y + ph + spacing > a.y + a.height) { st.area = (st.area + 1) % areas.length; st.x = areas[st.area].x; st.y = areas[st.area].y } } positions[order[i]] = { x: st.x + (Math.random() - .5) * 10, y: st.y + (Math.random() - .5) * 10 }; st.x += pw + spacing; st.maxH = Math.max(st.maxH, ph) } puzzleState.pieces.forEach((p, i) => { p.x = positions[p.id].x; p.y = positions[p.id].y; p.groupId = p.id; p.zIndex = i + 1; p.isFixed = false }); puzzleState.groups = puzzleState.pieces.map(p => ({ id: p.groupId, pieces: [p.id], x: p.x, y: p.y })); puzzleState.isComplete = false; puzzleState.showPreview = false; elements.previewBtn.classList.remove("active"); renderPuzzle(); startTimer(); }
    const resetPuzzle = () => { if (!puzzleState.image) return; puzzleState.pieces = []; puzzleState.groups = []; puzzleState.isComplete = false; puzzleState.showPreview = false; elements.previewBtn.classList.remove("active"); stopTimer(); elements.timerDisplay.textContent = "00:00"; elements.puzzleComplete.style.display = "none"; createPuzzlePieces(); }
    const startTimer = () => { if (puzzleState.timerInterval) clearInterval(puzzleState.timerInterval); puzzleState.startTime = Date.now(); puzzleState.timerInterval = setInterval(updateTimer, 1000); }
    const updateTimer = () => { if (!puzzleState.startTime) return; const e = Math.floor((Date.now() - puzzleState.startTime) / 1000), m = Math.floor(e / 60), s = e % 60; elements.timerDisplay.textContent = `${m.toString().padStart(2, "0")}:${s.toString().padStart(2, "0")}` }
    const stopTimer = () => { if (puzzleState.timerInterval) clearInterval(puzzleState.timerInterval); puzzleState.timerInterval = null; }
    const togglePreview = () => { puzzleState.showPreview = !puzzleState.showPreview; const btn = elements.previewBtn; if (puzzleState.showPreview) btn.classList.add("active"); else btn.classList.remove("active"); renderPuzzle(); }

    elements.startBtn.addEventListener('click', () => initPuzzle(modalNode.dataset.productImage));
    elements.shuffleBtn.addEventListener('click', shufflePieces);
    elements.resetBtn.addEventListener('click', resetPuzzle);
    elements.previewBtn.addEventListener('click', togglePreview);
    elements.difficultySelect.addEventListener("change", e => { puzzleState.difficulty = e.target.value; if (puzzleState.image) resetPuzzle(); });
    
    modalNode.addEventListener("mousemove", handleMouseMove);
    modalNode.addEventListener("mouseup", handleMouseUp);
    modalNode.addEventListener("touchmove", e => { if (puzzleState.draggedGroup) { e.preventDefault(); const t = e.touches[0]; handleMouseMove(new MouseEvent("mousemove", { clientX: t.clientX, clientY: t.clientY, bubbles: true })); } }, { passive: false });
    modalNode.addEventListener("touchend", handleMouseUp);
  }
};